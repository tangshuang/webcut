# WebCut 视频转场优化方案

## 1. 现状分析

### 1.1 当前实现架构

当前视频转场实现基于 WebAV 的 `tickInterceptor` 机制，主要逻辑位于 `hooks/index.ts` 中的 `syncSourceTickInterceptor` 函数：

1. **转场触发机制**：每个视频 clip 注册独立的 `tickInterceptor`，在每帧渲染时检查是否需要应用转场
2. **转场处理流程**：
   - 拦截 clip 的 tick 事件，获取当前帧
   - 检查当前时间是否处于转场区间
   - 查找相邻的视频片段
   - 获取前后片段的帧数据（使用简单的首帧/尾帧缓存）
   - 应用转场效果
   - 返回处理后的帧

### 1.2 存在的问题

根据用户反馈和代码分析，当前实现存在以下问题：

1. **性能问题**：
   - 每帧都需要执行转场检查和计算
   - 转场计算与渲染耦合，实时计算压力大
   - 帧数据获取和处理开销大

2. **破坏 clip 本身播放效果**：
   - `tickInterceptor` 直接修改 clip 的原始输出
   - 可能导致 clip 自身的播放逻辑受到影响

3. **视频跳动问题**：
   - 转场前后的帧衔接不流畅
   - 转场开始和结束时存在明显跳变

4. **架构设计问题**：
   - 转场逻辑分散在各个 clip 的 interceptor 中
   - 帧缓存机制不完善，只缓存首帧和尾帧
   - 转场计算复杂，每帧都需要查找相关 segment 和 transition

## 2. 优化方案

### 2.1 核心优化思路

1. **从 clip 级转场转向全局转场管理**：
   - 优化每个 clip 的独立 `tickInterceptor`，移除转场相关代码
   - 在更高层级统一管理所有转场
   - 实现转场与 clip 播放的解耦

2. **优化转场触发机制**：
   - 预计算转场时间区间
   - 只在必要时执行转场计算
   - 减少每帧的计算开销

3. **改进帧处理流程**：
   - 优化帧缓存机制
   - 减少视频帧的创建和销毁
   - 利用 GPU 加速转场渲染

4. **架构重构**：
   - 分离转场触发、计算和渲染逻辑
   - 建立清晰的转场状态管理
   - 实现模块化设计，便于扩展和维护

### 2.2 具体实现方案

#### 方案 1：全局转场管理器 + 统一帧处理

**核心思想**：在 AVCanvas 或播放器级别实现全局转场管理，统一处理所有转场效果。

**架构设计**：

```
┌─────────────────────────────────────────────────────────┐
│                     播放器层 (Player)                    │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌───────────┐ │
│  │  视频轨道管理   │  │  音频轨道管理   │  │ 转场管理  │ │
│  └─────────────────┘  └─────────────────┘  └───────────┘ │
├─────────────────────────────────────────────────────────┤
│                     渲染层 (AVCanvas)                    │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌───────────┐ │
│  │  视频渲染引擎   │  │  音频渲染引擎   │  │ 转场渲染  │ │
│  └─────────────────┘  └─────────────────┘  └───────────┘ │
└─────────────────────────────────────────────────────────┘
```

**关键改进点**：

1. **移除 clip 级别的 tickInterceptor**
2. 在播放器层实现转场检测和调度
3. 建立全局帧缓存系统
4. 实现转场效果的预计算和缓存
5. 利用 WebGL 加速转场渲染

#### 方案 2：预渲染转场效果

**核心思想**：将转场效果预渲染为临时视频片段，减少实时计算压力。

**实现流程**：

1. 当用户添加或修改转场时，触发预渲染
2. 预渲染转场效果为临时视频文件
3. 在播放时直接使用预渲染的转场片段
4. 支持动态更新和重新预渲染

**优点**：
- 播放时性能优异，无需实时计算
- 转场效果稳定，不会出现卡顿
- 支持复杂的转场效果

**缺点**：
- 需要额外的存储空间
- 转场修改后需要重新预渲染
- 实现复杂度较高

#### 方案 3：优化现有 tickInterceptor 机制

**核心思想**：保留现有架构，但对关键部分进行优化。

**关键优化**：

1. 移除 tickInterceptor 中的转场相关代码，将转场逻辑迁移到全局管理器
2. 优化剩余的 tickInterceptor 逻辑（滤镜和静音处理）
3. 改进帧缓存机制，增加缓存容量和智能缓存策略
4. 实现转场效果的 GPU 加速
5. 优化视频帧的创建和销毁逻辑
6. 减少不必要的视频帧克隆

**优点**：
- 改动较小，易于实现
- 兼容性好
- 风险较低

**缺点**：
- 性能提升有限
- 无法解决架构层面的根本问题

### 2.3 推荐方案

综合考虑性能、实现复杂度和兼容性，推荐采用 **方案 1：全局转场管理器 + 统一帧处理**。

**推荐理由**：
1. 从根本上解决了当前架构的设计问题
2. 性能提升显著
3. 架构清晰，便于扩展和维护
4. 支持更复杂的转场效果
5. 为未来功能扩展奠定基础

## 3. 实施步骤

### 3.1 阶段 1：架构重构

1. **创建全局转场管理器**：
   - 实现 `GlobalTransitionManager` 类
   - 负责管理所有转场效果
   - 实现转场的注册、检测和应用

2. **优化 clip 级别的 tickInterceptor**：
   - 保留 `syncSourceTickInterceptor` 函数
   - 移除其中的转场相关代码，保留滤镜和静音操作处理
   - 优化 tickInterceptor 逻辑，减少每帧计算开销

3. **实现全局帧缓存系统**：
   - 创建 `FrameCache` 类
   - 实现高效的帧缓存管理
   - 支持智能缓存策略

### 3.2 阶段 2：转场渲染优化

1. **实现 WebGL 加速渲染**：
   - 创建 `WebGLTransitionRenderer` 类
   - 利用 GPU 加速转场效果渲染
   - 实现常用转场效果的 WebGL 着色器

2. **优化视频帧处理**：
   - 减少视频帧的创建和销毁
   - 优化视频帧的克隆和转换
   - 实现帧数据的高效传递

3. **改进转场触发机制**：
   - 预计算所有转场的时间区间
   - 实现高效的转场查找算法
   - 只在必要时执行转场计算

### 3.3 阶段 3：功能完善和测试

1. **实现转场效果的预计算**：
   - 支持转场效果的预计算和缓存
   - 实现预计算的智能触发机制

2. **完善转场效果库**：
   - 优化现有转场效果
   - 添加新的转场效果
   - 实现转场效果的参数化配置

3. **性能测试和优化**：
   - 进行全面的性能测试
   - 优化关键路径
   - 解决性能瓶颈

4. **兼容性测试**：
   - 在不同浏览器和设备上测试
   - 确保转场效果的一致性
   - 解决兼容性问题

## 4. 预期效果

### 4.1 性能提升

- 减少每帧的计算量，降低 CPU 使用率
- 利用 GPU 加速，提高渲染性能
- 优化帧缓存，减少重复计算
- 预计性能提升 50% 以上

### 4.2 播放质量改善

- 消除转场前后的视频跳动
- 实现平滑的转场效果
- 保持 clip 自身的播放效果不受影响
- 提高视频播放的整体流畅度

### 4.3 架构改进

- 实现转场逻辑与 clip 播放的解耦
- 建立清晰的模块化架构
- 便于扩展和维护
- 支持更复杂的转场效果

### 4.4 开发体验提升

- 简化转场效果的开发流程
- 提供清晰的 API 接口
- 便于调试和测试
- 支持热更新和实时预览

## 5. 技术实现细节

### 5.1 全局转场管理器设计

```typescript
class GlobalTransitionManager {
  private transitions: Map<string, Transition[]> = new Map();
  private frameCache: FrameCache;
  private renderer: TransitionRenderer;

  // 注册转场效果
  registerTransition(transition: Transition): void;

  // 检测当前时间是否需要应用转场
  detectTransitions(time: number): TransitionInfo[];

  // 应用转场效果
  async applyTransitions(
    sprites: VisibleSprite[],
    time: number,
    frameData: FrameData[]
  ): Promise<FrameData[]>;

  // 预计算转场效果
  precomputeTransitions(): Promise<void>;
}
```

### 5.2 帧缓存系统设计

```typescript
class FrameCache {
  private cache: Map<string, Map<number, VideoFrame>> = new Map();
  private maxSize: number;
  private lru: Map<string, number[]> = new Map();

  // 获取帧数据
  getFrame(spriteId: string, time: number): VideoFrame | null;

  // 缓存帧数据
  cacheFrame(spriteId: string, time: number, frame: VideoFrame): void;

  // 预缓存关键帧
  preCacheFrames(sprite: VisibleSprite): Promise<void>;

  // 清理缓存
  clearCache(spriteId?: string): void;
}
```

### 5.3 WebGL 转场渲染器设计

```typescript
class WebGLTransitionRenderer {
  private gl: WebGL2RenderingContext;
  private programs: Map<string, WebGLProgram> = new Map();

  // 初始化 WebGL 上下文
  init(canvas: HTMLCanvasElement | OffscreenCanvas): void;

  // 渲染转场效果
  renderTransition(
    fromFrame: VideoFrame,
    toFrame: VideoFrame,
    progress: number,
    transitionType: string,
    config: TransitionConfig
  ): Promise<VideoFrame>;

  // 编译转场着色器
  compileShader(transitionType: string): WebGLProgram;

  // 释放资源
  destroy(): void;
}
```

## 6. 风险评估

### 6.1 技术风险

1. **WebGL 兼容性问题**：
   - 不同浏览器对 WebGL 的支持程度不同
   - 某些设备可能不支持 WebGL 2.0
   - 解决方案：实现降级方案，在不支持 WebGL 的情况下使用 Canvas 渲染

2. **性能问题**：
   - 全局转场管理可能引入新的性能瓶颈
   - 解决方案：进行充分的性能测试和优化，实现智能调度机制

3. **架构复杂度增加**：
   - 新架构的复杂度较高，可能增加开发和维护成本
   - 解决方案：建立完善的文档和测试用例，实现模块化设计

### 6.2 实施风险

1. **开发周期较长**：
   - 架构重构需要较长时间
   - 解决方案：分阶段实施，逐步推进

2. **兼容性问题**：
   - 新架构可能与现有代码存在兼容性问题
   - 解决方案：进行充分的测试，确保向后兼容

3. **测试复杂度高**：
   - 需要测试各种转场效果和场景
   - 解决方案：建立完善的测试用例，实现自动化测试

## 7. 结论

当前的视频转场实现存在性能问题、播放质量问题和架构设计问题。通过采用全局转场管理器 + 统一帧处理的方案，可以从根本上解决这些问题，实现性能提升、播放质量改善和架构优化。

该方案具有以下优势：
1. 性能提升显著
2. 架构清晰，便于扩展和维护
3. 支持更复杂的转场效果
4. 为未来功能扩展奠定基础

建议按照实施步骤逐步推进，确保方案的顺利实施。