# 文件处理流程优化方案

## 1. 执行摘要

本文档分析了 webcut 项目中文件处理流程的性能瓶颈，并提出了相应的优化方案。当前项目使用 opfs-tools 作为工具来保存上传到视频编辑器的素材，由于它是在 worker 中操作 OPFS，导致用户在上传大文件时需要等待较长时间。通过优化文件哈希计算、OPFS 文件写入、添加上传进度反馈等措施，可以显著提高文件上传的性能和用户体验。

## 2. 技术背景

### 2.1 项目文件处理流程

1. **文件上传入口**：通过 `useWebCutLibrary` 中的 `addNewFile` 函数
2. **文件处理流程**：
   - 计算文件 MD5（使用 `browser-md5-file` 库）
   - 检查文件是否已存在（OPFS 和项目文件列表）
   - 调用 `addFile` 函数保存文件
   - `addFile` 调用 `writeFile` 函数
   - `writeFile` 使用 `opfs-tools` 库将文件写入 OPFS
3. **主要依赖**：
   - `browser-md5-file`: 用于计算文件 MD5
   - `opfs-tools`: 用于操作 OPFS
   - `indb`: 用于 IndexedDB 操作

### 2.2 主要瓶颈

1. **文件 MD5 计算在主线程执行**：对于大文件可能导致界面卡顿
2. **OPFS 文件写入使用串行队列**：`AsyncQueue` 导致大文件上传等待时间长
3. **缺少详细的上传进度反馈**：用户体验差
4. **opfs-tools 本身的流处理方式**：逐块读取和写入导致的等待时间
5. **重复的文件存在性检查**：增加了额外的开销

## 3. 优化方案

### 3.1 优化文件哈希计算

**问题**：当前使用 `browser-md5-file` 库在主线程计算文件 MD5，对于大文件可能导致界面卡顿。

**优化方案**：
- 将 MD5 计算移到 Web Worker 中执行
- 或者使用更高效的哈希算法，如 SHA-1 或 SHA-256（现代浏览器提供原生支持）
- 考虑使用文件内容的一部分计算哈希，减少计算量

**实现建议**：
```typescript
// 将 MD5 计算移到 Web Worker 中执行
// src/libs/file-hash-worker.ts
self.onmessage = async (e) => {
  const file = e.data;
  const hashBuffer = await crypto.subtle.digest('SHA-1', await file.arrayBuffer());
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  self.postMessage(hashHex);
};

// src/libs/file.ts
export function getFileMd5(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const worker = new Worker(new URL('./file-hash-worker.ts', import.meta.url));
    worker.onmessage = (e) => {
      resolve(e.data);
      worker.terminate();
    };
    worker.onerror = (e) => {
      reject(e.error);
      worker.terminate();
    };
    worker.postMessage(file);
  });
}
```

### 3.2 优化 OPFS 文件写入

**问题**：当前使用 `AsyncQueue` 串行处理文件写入，大文件上传等待时间长。

**优化方案**：
- 移除或优化 `AsyncQueue`，允许多个文件并行写入
- 或者为不同类型的文件创建不同的队列，优先处理小文件
- 考虑使用更高效的文件写入方式，如直接使用 OPFS API 而非 opfs-tools

**实现建议**：
```typescript
// 移除或优化 AsyncQueue
// src/db/index.ts
// const queue = new AsyncQueue();

export async function writeFile(f: File) {
  const fileId = await getFileMd5(f);
  const opfsFilePath = `/webcut/file/${fileId}`;

  if (await file(opfsFilePath).exists()) {
    return fileId;
  }

  // 直接写入，不使用队列
  await write(opfsFilePath, f.stream(), { overwrite: true });

  // ... 其余代码
}
```

### 3.3 添加上传进度反馈

**问题**：当前文件上传过程中没有详细的进度反馈，用户体验差。

**优化方案**：
- 添加上传进度事件，允许组件监听并显示进度
- 为文件哈希计算和文件写入分别添加进度反馈
- 实现上传取消功能，允许用户中断长时间的上传

**实现建议**：
```typescript
// src/hooks/library.ts
export function useWebCutLibrary() {
  // ... 现有代码

  const uploadProgress = ref(0);

  async function addNewFile(file: File, onProgress?: (progress: number) => void) {
    loading.value = true;
    uploadProgress.value = 0;
    try {
      // 计算哈希时的进度反馈
      onProgress?.(10);

      let fileId = await getFileMd5(file);
      onProgress?.(30);

      if (projectFiles.value.some((item: any) => item.id === fileId)) {
        onProgress?.(100);
        return;
      }

      if (!files.value.some((item: any) => item.id === fileId)) {
        // 写入文件时的进度反馈
        await addFile(file, (progress) => {
          onProgress?.(30 + progress * 0.6);
        });
      }

      onProgress?.(90);
      await addFileToProject(projectId.value, fileId);
      await refreshProjectData();
      await refreshFiles();
      onProgress?.(100);
    } finally {
      loading.value = false;
    }
  }

  return {
    // ... 现有返回值
    uploadProgress,
    addNewFile,
  };
}
```

### 3.4 优化 opfs-tools 的使用

**问题**：opfs-tools 本身的流处理方式可能存在性能问题，如逐块读取和写入导致的等待时间。

**优化方案**：
- 考虑直接使用 OPFS API，减少中间层开销
- 或者优化 opfs-tools 的使用方式，如使用更高效的流处理方式
- 考虑使用其他 OPFS 库或实现

**实现建议**：
```typescript
// 直接使用 OPFS API 的示例
async function writeFileDirect(f: File) {
  const fileId = await getFileMd5(f);

  // 获取 OPFS 根目录
  const root = await navigator.storage.getDirectory();

  // 创建目录结构
  const webcutDir = await root.getDirectoryHandle('webcut', { create: true });
  const fileDir = await webcutDir.getDirectoryHandle('file', { create: true });

  // 创建或覆盖文件
  const fileHandle = await fileDir.getFileHandle(fileId, { create: true });
  const writable = await fileHandle.createWritable();

  // 使用流写入文件
  await f.stream().pipeTo(writable);

  return fileId;
}
```

### 3.5 实现文件上传的异步处理

**问题**：当前文件上传是同步的，用户需要等待上传完成才能继续操作。

**优化方案**：
- 实现文件上传的异步处理，允许用户在上传过程中继续使用编辑器
- 为上传中的文件添加状态标记
- 实现上传失败的重试机制

**实现建议**：
```typescript
// src/hooks/library.ts
export function useWebCutLibrary() {
  // ... 现有代码

  const uploadingFiles = ref<Map<string, { file: File; progress: number }>>(new Map());

  async function addNewFile(file: File) {
    const fileId = await getFileMd5(file);

    // 检查文件是否已存在
    if (projectFiles.value.some((item: any) => item.id === fileId)) {
      return;
    }

    // 添加到上传队列
    uploadingFiles.value.set(fileId, { file, progress: 0 });

    // 异步处理上传
    setTimeout(async () => {
      try {
        if (!files.value.some((item: any) => item.id === fileId)) {
          await addFile(file);
        }
        await addFileToProject(projectId.value, fileId);
        await refreshProjectData();
        await refreshFiles();
      } finally {
        // 从上传队列中移除
        uploadingFiles.value.delete(fileId);
      }
    }, 0);
  }

  return {
    // ... 现有返回值
    uploadingFiles,
    addNewFile,
  };
}
```

## 4. 优化方案对比

| 优化方案 | 预期效果 | 实现难度 | 对现有代码的影响 |
|---------|---------|---------|----------------|
| 优化文件哈希计算 | 减少主线程阻塞，提高大文件处理速度 | 中 | 需要修改 `getFileMd5` 函数和相关调用 |
| 优化 OPFS 文件写入 | 提高文件写入效率，减少等待时间 | 低 | 需要修改 `writeFile` 函数 |
| 添加上传进度反馈 | 改善用户体验，提供详细的进度信息 | 中 | 需要修改 `addNewFile` 函数和相关组件 |
| 优化 opfs-tools 的使用 | 减少中间层开销，提高文件处理速度 | 高 | 需要修改文件写入相关代码，可能影响兼容性 |
| 实现文件上传的异步处理 | 允许用户在上传过程中继续操作 | 中 | 需要修改 `addNewFile` 函数和相关组件 |

## 5. 推荐方案

根据以上分析，推荐采用以下综合优化方案：

1. **将文件哈希计算移到 Web Worker 中执行**（优先级：高）
   - 减少主线程阻塞，提高大文件处理速度
   - 实现难度适中，对现有代码影响较小

2. **优化 OPFS 文件写入，移除或优化串行队列**（优先级：高）
   - 提高文件写入效率，减少等待时间
   - 实现难度低，对现有代码影响小

3. **添加上传进度反馈**（优先级：中）
   - 改善用户体验，提供详细的进度信息
   - 实现难度适中，对现有代码影响较小

4. **实现文件上传的异步处理**（优先级：中）
   - 允许用户在上传过程中继续操作
   - 实现难度适中，对现有代码影响较小

5. **考虑直接使用 OPFS API**（优先级：低）
   - 减少中间层开销，提高文件处理速度
   - 实现难度高，可能影响兼容性，建议在后续版本中考虑

## 6. 实现步骤

### 6.1 短期优化（1-2 周）

1. **优化文件哈希计算**
   - 创建 Web Worker 用于计算文件哈希
   - 修改 `getFileMd5` 函数，使用 Web Worker 计算哈希
   - 测试不同哈希算法的性能，选择最优方案

2. **优化 OPFS 文件写入**
   - 移除或优化 `AsyncQueue`，允许多个文件并行写入
   - 测试并行写入的性能和稳定性

### 6.2 中期优化（2-4 周）

1. **添加上传进度反馈**
   - 在 `useWebCutLibrary` 中添加上传进度状态
   - 修改 `addNewFile` 函数，添加进度回调
   - 更新组件，显示上传进度

2. **实现文件上传的异步处理**
   - 修改 `addNewFile` 函数，使其返回 Promise 但不阻塞用户操作
   - 为上传中的文件添加状态标记
   - 实现上传失败的重试机制

### 6.3 长期优化（4-8 周）

1. **考虑直接使用 OPFS API**
   - 研究 OPFS API 的使用方式和性能
   - 实现直接使用 OPFS API 的文件写入功能
   - 测试和比较与 opfs-tools 的性能差异
   - 考虑是否替换 opfs-tools

## 7. 预期效果

通过以上优化，预计可以：

1. **减少文件上传过程中的界面卡顿**：将文件哈希计算移到 Web Worker 中执行，避免阻塞主线程
2. **提高大文件上传的速度**：优化 OPFS 文件写入，允许多个文件并行写入
3. **改善用户体验**：提供详细的上传进度反馈，允许用户在上传过程中继续操作
4. **提高整体文件处理的效率和可靠性**：减少中间层开销，优化流处理方式

## 8. 风险评估

1. **兼容性风险**：直接使用 OPFS API 可能影响兼容性，需要进行充分的浏览器测试
2. **性能风险**：并行写入文件可能导致系统资源占用过高，需要进行性能测试
3. **数据完整性风险**：移除串行队列可能导致文件写入冲突，需要确保数据完整性
4. **代码复杂度风险**：添加上传进度反馈和异步处理可能增加代码复杂度，需要进行充分的测试

## 9. 后续优化建议

1. **实现文件分片上传**：对于超大文件，考虑实现分片上传，提高上传速度和可靠性
2. **添加文件压缩功能**：对于某些类型的文件，如图片，可以在上传前进行压缩，减少文件大小
3. **实现文件预加载**：对于常用的文件，可以在后台预加载，提高访问速度
4. **添加文件缓存机制**：对于频繁访问的文件，可以添加缓存机制，减少重复读取
5. **优化文件读取性能**：对于大文件读取，考虑实现流式读取，减少内存占用

## 10. 结论

通过优化文件哈希计算、OPFS 文件写入、添加上传进度反馈、实现文件上传的异步处理等措施，可以显著提高 webcut 项目中文件处理的性能和用户体验。建议按照推荐的优先级顺序逐步实现这些优化方案，以达到最佳的优化效果。